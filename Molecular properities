# =====================================================================

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from math import pi
from rdkit import Chem
from rdkit.Chem import Descriptors, Crippen, Lipinski, QED
files = {csv
}

sns.set_theme(style="whitegrid", font="Arial", font_scale=1.2)

def detect_smiles_column(df):
    for c in df.columns:
        if "smile" in c.lower():
            return c
    return df.columns[0]
def load_smiles(path):
    df = pd.read_csv(path, encoding="latin-1")
    return df[detect_smiles_column(df)].dropna().astype(str).tolist()
def rdkit_sas_proxy(m):
    mw = Descriptors.MolWt(m)
    logp = Crippen.MolLogP(m)
    tpsa = Descriptors.TPSA(m)
    rotb = Lipinski.NumRotatableBonds(m)
    rings = m.GetRingInfo().NumRings()
    arom = sum(a.GetIsAromatic() for a in m.GetAtoms())
    heavy = m.GetNumHeavyAtoms()
    arom_ratio = arom / heavy if heavy else 0
    raw = 0.03*mw + 0.8*arom_ratio + 0.5*rings + 0.4*rotb + 0.3*abs(logp) + 0.01*tpsa
    return round(min(max(1 + 9*(raw-1)/(10+raw), 1), 10), 3)


def compute_props(smiles, model):
    rows = []
    for s in smiles:
        m = Chem.MolFromSmiles(s)
        if m:
            rows.append({
                "Model": model,
                "MW": Descriptors.MolWt(m),
                "LogP": Crippen.MolLogP(m),
                "HBD": Lipinski.NumHDonors(m),
                "HBA": Lipinski.NumHAcceptors(m),
                "TPSA": Descriptors.TPSA(m),
                "RotBonds": Lipinski.NumRotatableBonds(m),
                "QED": QED.qed(m),
                "SAS": rdkit_sas_proxy(m)
            })
    return pd.DataFrame(rows)

dfs = []
for model, path in files.items():
    print(f"Processing {model}")
    dfs.append(compute_props(load_smiles(path), model))

df = pd.concat(dfs, ignore_index=True)
df.to_csv(os.path.join(OUT, "All_Models_Properties.csv"), index=False)

props = ["MW", "LogP", "HBD", "HBA", "TPSA", "RotBonds", "QED", "SAS"]

for p in props:
    # KDE
    plt.figure(figsize=(7.5,5))
    sns.kdeplot(data=df, x=p, hue="Model", hue_order=MODEL_ORDER,
                palette=PALETTE, bw_adjust=0.8, common_norm=False)
    plt.savefig(f"{OUT}/{p}_KDE.png", dpi=300); plt.close()

    # Histogram + KDE
    plt.figure(figsize=(7.5,5))
    sns.histplot(data=df, x=p, hue="Model", hue_order=MODEL_ORDER,
                 palette=PALETTE, kde=True, stat="density", common_norm=False)
    plt.savefig(f"{OUT}/{p}_Histogram.png", dpi=300); plt.close()

    # Violin + Box
    plt.figure(figsize=(8,5))
    sns.violinplot(data=df, x="Model", y=p, order=MODEL_ORDER,
                   palette=PALETTE, inner=None)
    sns.boxplot(data=df, x="Model", y=p, order=MODEL_ORDER,
                width=0.25, showcaps=True, showfliers=False)
    plt.savefig(f"{OUT}/{p}_Violin.png", dpi=300); plt.close()

radar_props = ["MW", "LogP", "HBD", "HBA", "QED", "SAS"]
radar_df = df.groupby("Model")[radar_props].mean()
radar_df = (radar_df - radar_df.min()) / (radar_df.max() - radar_df.min())

angles = np.linspace(0, 2*pi, len(radar_props), endpoint=False).tolist()
angles += angles[:1]

plt.figure(figsize=(7,7))
ax = plt.subplot(111, polar=True)

for model in MODEL_ORDER:
    values = radar_df.loc[model].tolist()
    values += values[:1]
    ax.plot(angles, values, label=model)
    ax.fill(angles, values, alpha=0.1)

ax.set_thetagrids(np.degrees(angles[:-1]), radar_props)
plt.legend(loc="upper right", bbox_to_anchor=(1.3,1.1))
plt.savefig(f"{OUT}/Radar_Model_Profile.png", dpi=300)
plt.close()

plt.figure(figsize=(7,5))
sns.scatterplot(data=df, x="QED", y="SAS", hue="Model", palette=PALETTE)
plt.savefig(f"{OUT}/QED_vs_SAS.png", dpi=300); plt.close()

plt.figure(figsize=(7,5))
sns.scatterplot(data=df, x="MW", y="LogP", hue="Model", palette=PALETTE)
plt.savefig(f"{OUT}/MW_vs_LogP.png", dpi=300); plt.close()

for model in MODEL_ORDER:
    plt.figure(figsize=(6,5))
    corr = df[df.Model==model][props].corr()
    sns.heatmap(corr, cmap="coolwarm", square=True)
    plt.title(model)
    plt.savefig(f"{OUT}/{model}_Correlation_Heatmap.png", dpi=300)
    plt.close()

sas_bar = df.groupby("Model")["SAS"].apply(lambda x: (x < 4).mean()*100).reset_index()

plt.figure(figsize=(6,5))
sns.barplot(data=sas_bar, x="Model", y="SAS", palette=PALETTE)
plt.ylabel("% SAS < 4")
plt.savefig(f"{OUT}/SAS_lt4_Bar.png", dpi=300)
plt.close()
